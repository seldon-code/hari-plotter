<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hari_plotter.cluster &mdash; Hari Plotter  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Hari Plotter
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples_page.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/modules.html">hari_plotter</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Hari Plotter</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">hari_plotter.cluster</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hari_plotter.cluster</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractclassmethod</span><span class="p">,</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">abstractproperty</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span>
                    <span class="n">Union</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">skfuzzy</span> <span class="k">as</span> <span class="nn">fuzz</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">silhouette_score</span>

<span class="kn">from</span> <span class="nn">.graph</span> <span class="kn">import</span> <span class="n">Graph</span>


<div class="viewcode-block" id="Clustering">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering">[docs]</a>
<span class="k">class</span> <span class="nc">Clustering</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class representing a cluster. It provides a template for clustering algorithms.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        clusters (List[np.ndarray]): A list of clusters, where each cluster is represented by a numpy array.</span>
<span class="sd">        centroids (np.ndarray): An array of centroids for the clusters.</span>
<span class="sd">        labels (np.ndarray): An array indicating the label of each data point.</span>
<span class="sd">        parameters (List[str]): A list of parameter names used for clustering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_clustering_methods</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        node_ids (np.ndarray): A numpy array of length N (length of nodes) representing node ids for each data point.</span>
<span class="sd">        cluster_indexes (np.ndarray): A numpy array of length N (length of nodes) shows what cluster each point from data belongs to</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">cluster_indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_ids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">node_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_clusters</span><span class="p">())]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span>

<div class="viewcode-block" id="Clustering.get_cluster_labels">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.get_cluster_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cluster_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span></div>


    <span class="nd">@cluster_labels</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cluster_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_clusters</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Labels number </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="si">}</span><span class="s1"> is not equal to the number of clusters </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_clusters</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span> <span class="o">=</span> <span class="n">labels</span>

<div class="viewcode-block" id="Clustering.label_to_index">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.label_to_index">[docs]</a>
    <span class="k">def</span> <span class="nf">label_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>


<div class="viewcode-block" id="Clustering.reorder_labels">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.reorder_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">current_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">]</span></div>


<div class="viewcode-block" id="Clustering.clustering_method">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.clustering_method">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">clustering_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">clustering_name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">clustering_func</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">clustering_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_clustering_methods</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;clustering type </span><span class="si">{</span><span class="n">clustering_name</span><span class="si">}</span><span class="s2"> is already defined.&quot;</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_clustering_methods</span><span class="p">[</span><span class="n">clustering_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustering_func</span>
            <span class="k">return</span> <span class="n">clustering_func</span>
        <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="Clustering.from_graph">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.from_graph">[docs]</a>
    <span class="nd">@abstractclassmethod</span>
    <span class="k">def</span> <span class="nf">from_graph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Clustering</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method must be implemented in subclasses&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Clustering.create_clustering">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.create_clustering">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_clustering</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">clustering_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;K-Means Clustering&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Clustering</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method that creates an instance of a subclass of `Clustering` based on the provided method name</span>
<span class="sd">        and applies specified scaling functions to the data before clustering.</span>

<span class="sd">        Args:</span>
<span class="sd">            clustering_method: The name of the clustering method corresponding to a subclass of `Clustering`.</span>
<span class="sd">            data: The data to be clustered, structured as a dictionary with the key &#39;data&#39; and value as another</span>
<span class="sd">                dictionary mapping integers to lists of float values.</span>
<span class="sd">            scale: An optional dictionary where keys are parameter names and values are functions (&#39;Linear&#39; or &#39;Tanh&#39;)</span>
<span class="sd">                to be applied to the parameter values before clustering. If not provided, no scaling is applied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An instance of the subclass of `Clustering` that corresponds to the given method name.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the method name is not recognized (i.e., not found in the `clustering_methods`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">clustering_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_clustering_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clustering method &#39;</span><span class="si">{</span><span class="n">clustering_method</span><span class="si">}</span><span class="s2">&#39; not recognized. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Available methods: </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">available_clustering_methods</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get the subclass corresponding to the method name</span>
        <span class="n">method_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_clustering_methods</span><span class="p">[</span><span class="n">clustering_method</span><span class="p">]</span>

        <span class="c1"># Create an instance of the subclass from the data, applying any specified scaling functions</span>
        <span class="k">return</span> <span class="n">method_cls</span><span class="o">.</span><span class="n">from_graph</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Clustering.get_number_of_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.get_number_of_clusters">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_number_of_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method to get the number of clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Clustering.available_clustering_methods">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.available_clustering_methods">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">available_clustering_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clustering_methods</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="Clustering.get_values">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.get_values">[docs]</a>
    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the values corresponding to the given parameter(s) for all points in the clusters.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (Union[str, List[str]]): The parameter name or list of parameter names.</span>
<span class="sd">            keep_scale *bool): For the convenience, some values are kept as the values of the scale function of themselves. You might need it as it is kept or the actual values, bu default, you need the actual values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[np.ndarray]: A list of numpy arrays, where each array corresponds to a cluster</span>
<span class="sd">                              and contains the values of the specified parameter(s) for each point in that cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Single parameter requested</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">gatherer</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">])</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_nodes_dict</span><span class="p">()]</span></div>


<div class="viewcode-block" id="Clustering.nodes_by_index">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.nodes_by_index">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the nodes that are in the cluster with the given label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_ids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indexes</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span></div>


<div class="viewcode-block" id="Clustering.nodes_by_label">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.nodes_by_label">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes_by_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the nodes that are in the cluster with the given label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_to_index</span><span class="p">(</span><span class="n">label</span><span class="p">))</span></div>


<div class="viewcode-block" id="Clustering.labels_nodes_dict">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.labels_nodes_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">labels_nodes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">cluster_label</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_label</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">}</span></div>


<div class="viewcode-block" id="Clustering.nodes_labels_dict">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.nodes_labels_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes_labels_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ln_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_nodes_dict</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="n">label</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">ln_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span></div>


<div class="viewcode-block" id="Clustering.nodes_labels_default_dict">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.Clustering.nodes_labels_default_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes_labels_default_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_labels_dict</span><span class="p">())</span></div>
</div>



<div class="viewcode-block" id="ParameterBasedClustering">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering">[docs]</a>
<span class="k">class</span> <span class="nc">ParameterBasedClustering</span><span class="p">(</span><span class="n">Clustering</span><span class="p">):</span>
    <span class="n">scale_funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Linear&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;direct&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;inverse&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">},</span>
        <span class="s1">&#39;Tanh&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;direct&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span> <span class="s1">&#39;inverse&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">}</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">scales</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Cluster object with cluster data.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_indexes: A numpy array of length N shows what cluster each point from data belongs to</span>
<span class="sd">            node_ids (np.ndarray): A numpy array of length N representing node ids for each data point. </span>
<span class="sd">            parameters (List[str]): A list of strings length M, representing the names of the parameters </span>
<span class="sd">                                    or features used in clustering. These names correspond to the </span>
<span class="sd">                                    dimensions/features in the data points. </span>
<span class="sd">            scales (List[str]): A list of strings representing the names of the scales used for clustering. More in scale_funcs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="o">=</span><span class="n">cluster_indexes</span><span class="p">,</span> <span class="n">node_ids</span><span class="o">=</span><span class="n">node_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ParameterBasedClustering.centroids">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unscaled_centroids</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_scale</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">):</span>
                <span class="n">centroids</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_funcs</span><span class="p">[</span><span class="n">sc</span><span class="p">][</span><span class="s1">&#39;inverse&#39;</span><span class="p">](</span>
                    <span class="n">centroids</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">centroids</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.unscaled_centroids">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.unscaled_centroids">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">unscaled_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array representing the centroids of the clusters.</span>
<span class="sd">        Each row in this array corresponds to a centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method must be implemented in subclasses&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.predict_cluster">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.predict_cluster">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">predict_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_point</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method to predict the cluster for a new data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.degree_of_membership">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.degree_of_membership">[docs]</a>
    <span class="k">def</span> <span class="nf">degree_of_membership</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_point</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the &#39;probability&#39; of belonging to each cluster for a new data point.</span>

<span class="sd">        If the clustering method does not provide probabilities, this method</span>
<span class="sd">        will return a list with a 1 at the index of the assigned cluster and 0s elsewhere.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_point: The new data point&#39;s parameter values as a list of floats.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[float]: A list of zeros and one one, indicating the cluster assignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nearest_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_cluster</span><span class="p">(</span><span class="n">data_point</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nearest_cluster_index</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_clusters</span><span class="p">())]</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.reorder_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.reorder_clusters">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">reorder_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method to reorder clusters based on a new order.</span>
<span class="sd">        Assumes that the new_order list contains the indices of the clusters in their new order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.get_indices_from_parameters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.get_indices_from_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_indices_from_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices corresponding to the given parameter(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            params (Union[str, List[str]]): The parameter name or list of parameter names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[int, List[int]]: The index or list of indices corresponding to the given parameter(s).</span>
<span class="sd">            Returns None if parameter is not present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="n">params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span></div>


<div class="viewcode-block" id="ParameterBasedClustering.get_parameters_from_indices">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ParameterBasedClustering.get_parameters_from_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_parameters_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parameter names corresponding to the given index/indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (Union[int, List[int]]): The index or list of indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[str, List[str]]: The parameter name or list of parameter names corresponding to the given index/indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="ValueIntervalsClustering">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering">[docs]</a>
<span class="nd">@Clustering</span><span class="o">.</span><span class="n">clustering_method</span><span class="p">(</span><span class="s2">&quot;Interval Clustering&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ValueIntervalsClustering</span><span class="p">(</span><span class="n">ParameterBasedClustering</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Value Intervals clustering representation, extending the generic Clustering class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">parameter_boundaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">scales</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">cluster_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_ids</span><span class="o">=</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                         <span class="n">scales</span><span class="o">=</span><span class="n">scales</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="o">=</span><span class="n">cluster_indexes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_boundaries</span> <span class="o">=</span> <span class="n">parameter_boundaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="ValueIntervalsClustering.get_number_of_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.get_number_of_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_number_of_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>  <span class="c1"># Assuming self.n_clusters tracks the number of clusters</span></div>


    <span class="c1"># def labels_nodes_dict(self) -&gt; List[list]:</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Maps each node to a cluster based on the parameter boundaries.</span>

    <span class="c1">#     Returns:</span>
    <span class="c1">#     - List[list]: A list of lists, where each sublist contains the nodes belonging to that cluster.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     cluster_nodes = [[] for _ in range(self.get_number_of_clusters())]</span>

    <span class="c1">#     for i, point in enumerate(self.data):</span>
    <span class="c1">#         cluster_index = self.find_cluster_index(point)</span>
    <span class="c1">#         if cluster_index is not None:  # Point falls within defined boundaries</span>
    <span class="c1">#             cluster_nodes[cluster_index].append(</span>
    <span class="c1">#                 tuple(self.node_ids[i]))</span>

    <span class="c1">#     return cluster_nodes</span>

<div class="viewcode-block" id="ValueIntervalsClustering.find_cluster_indices_on_grid">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.find_cluster_indices_on_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">find_cluster_indices_on_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the indices of the clusters a point belongs to based on parameter boundaries.</span>

<span class="sd">        Args:</span>
<span class="sd">        - point: The data point&#39;s parameter values as a numpy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - np.ndarray: An array of the indices of the clusters the point belongs to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_boundaries</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">boundaries</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_boundaries</span><span class="p">):</span>
            <span class="n">cluster_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundaries</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cluster_indices</span></div>


    <span class="c1"># def find_cluster_index(self, point):</span>
    <span class="c1">#     cluster_indices = self.find_cluster_indices_on_grid(point)</span>
    <span class="c1">#     return self._indices_mapping.get(cluster_indices, None)</span>

<div class="viewcode-block" id="ValueIntervalsClustering.from_graph">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.from_graph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_graph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">parameter_boundaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">clustering_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">scale</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ValueIntervalsClustering&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an instance of valueIntervalsClustering from a HariGraph.</span>

<span class="sd">        Args:</span>
<span class="sd">            G: HariGraph.</span>
<span class="sd">            parameter_boundaries: List of lists, each containing the boundaries for a parameter.</span>
<span class="sd">            clustering_parameters: List of parameter names.</span>
<span class="sd">            scale: Optional scaling functions for the clustering_parameters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            valueIntervalsClustering: An instance with nodes assigned to clusters based on the parameter boundaries.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the number of clustering_parameters does not match the number of parameter boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustering_parameters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_boundaries</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of clustering_parameters must match the number of parameter boundaries.&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">gatherer</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">clustering_parameters</span><span class="p">)</span>

        <span class="c1"># Validate and process scale argument</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;Linear&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">clustering_parameters</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustering_parameters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length mismatch in scale list&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Linear&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustering_parameters</span><span class="p">)</span>

        <span class="c1"># Prepare data array</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">clustering_parameters</span> <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Nodes&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Remove NaN values</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Nodes&#39;</span><span class="p">])[</span><span class="n">valid_indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No data points remain after removing NaN values.&quot;</span><span class="p">)</span>

        <span class="c1"># Apply scaling to the clustering_parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">data_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">scale_funcs</span><span class="p">[</span><span class="n">sc</span><span class="p">][</span><span class="s1">&#39;direct&#39;</span><span class="p">](</span><span class="n">data_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># Initialize the clustering</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data_array</span><span class="p">,</span> <span class="n">node_ids</span><span class="o">=</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">clustering_parameters</span><span class="p">,</span>
                         <span class="n">scales</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">parameter_boundaries</span><span class="o">=</span><span class="n">parameter_boundaries</span><span class="p">)</span>
        <span class="n">clustering</span><span class="o">.</span><span class="n">recluster</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clustering</span></div>


<div class="viewcode-block" id="ValueIntervalsClustering.recluster">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.recluster">[docs]</a>
    <span class="k">def</span> <span class="nf">recluster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates the cluster indices for each data point based on the current parameter boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over each data point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># Determine the cluster indices for the current point across all parameters</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_cluster_indices_on_grid</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cluster_indices</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_mapping</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_indices_mapping</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Flatten these indices into a single cluster index</span>
            <span class="c1"># flat_cluster_index = self.flatten_cluster_indices(cluster_indices)</span>

            <span class="c1"># Update the cluster index for the current point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_mapping</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="ValueIntervalsClustering.reorder_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.reorder_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="c1"># Implement the logic to reorder the clusters</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ValueIntervalsClustering.unscaled_centroids">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.unscaled_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">unscaled_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_indexes</span> <span class="o">==</span> <span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)])</span></div>


<div class="viewcode-block" id="ValueIntervalsClustering.predict_cluster">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.ValueIntervalsClustering.predict_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">predict_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">points_scaled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the cluster indices to which new data points belong based on the centroids.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_points: The new data points&#39; parameter values as a numpy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array of indices of the closest cluster centroid to each data point.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the dimensionality of the data points does not match that of the centroids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the data points are of the correct dimension</span>
        <span class="k">if</span> <span class="n">data_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data points dimensionality does not match number of parameters&quot;</span><span class="p">)</span>
        <span class="n">scaled_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">points_scaled</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">):</span>
                <span class="n">scaled_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_funcs</span><span class="p">[</span><span class="n">sc</span><span class="p">][</span><span class="s1">&#39;direct&#39;</span><span class="p">](</span>
                    <span class="n">scaled_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="n">cluster_indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_points</span><span class="p">):</span>
            <span class="c1"># Determine the cluster indices for the current point across all parameters</span>
            <span class="n">cluster_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_cluster_index</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cluster_indexes</span></div>
</div>


    <span class="c1"># def get_values(self, key: Union[str, List[str]], keep_scale: bool = False) -&gt; List[np.ndarray]:</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns the values corresponding to the given parameter(s) for all points in the clusters.</span>

    <span class="c1">#     Args:</span>
    <span class="c1">#         key (Union[str, List[str]]): The parameter name or list of parameter names.</span>
    <span class="c1">#         keep_scale *bool): For the convenience, some values are kept as the values of the scale function of themselves. You might need it as it is kept or the actual values, bu default, you need the actual values.</span>

    <span class="c1">#     Returns:</span>
    <span class="c1">#         List[np.ndarray]: A list of numpy arrays, where each array corresponds to a cluster</span>
    <span class="c1">#                           and contains the values of the specified parameter(s) for each point in that cluster.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if isinstance(key, str):</span>
    <span class="c1">#         # Single parameter requested</span>
    <span class="c1">#         key = [key]</span>

    <span class="c1">#     if not all(k in self.parameters for k in key):</span>
    <span class="c1">#         raise KeyError(</span>
    <span class="c1">#             f&quot;One or more requested parameters {key} are not found in the cluster parameters {self.parameters}.&quot;)</span>

    <span class="c1">#     param_indices = [self.parameters.index(k) for k in key]</span>

    <span class="c1">#     scaled_data = self.data[:, param_indices]</span>
    <span class="c1">#     if not keep_scale:</span>
    <span class="c1">#         for new_index, original_index in enumerate(param_indices):</span>
    <span class="c1">#             used_scale = self.scales[original_index]</span>
    <span class="c1">#             scaled_data[:, new_index] = self.scale_funcs[used_scale][&#39;inverse&#39;](</span>
    <span class="c1">#                 scaled_data[:, new_index])</span>

    <span class="c1">#     unique = np.unique(self.cluster_indexes)</span>

    <span class="c1">#     return [scaled_data[self.cluster_indexes == u_i, :] for u_i in unique]</span>


<div class="viewcode-block" id="KMeansClustering">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering">[docs]</a>
<span class="nd">@Clustering</span><span class="o">.</span><span class="n">clustering_method</span><span class="p">(</span><span class="s2">&quot;K-Means Clustering&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">KMeansClustering</span><span class="p">(</span><span class="n">ParameterBasedClustering</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A KMeans clustering representation, extending the generic Clustering class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">scales</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">cluster_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_ids</span><span class="o">=</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                         <span class="n">scales</span><span class="o">=</span><span class="n">scales</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="o">=</span><span class="n">cluster_indexes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="KMeansClustering.unscaled_centroids">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.unscaled_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">unscaled_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="c1"># def labels_nodes_dict(self) -&gt; Dict[str, Tuple[Tuple[int]]]:</span>
    <span class="c1">#     return {cluster_label: ids for cluster_label, ids in zip(self.cluster_labels, self.node_ids)}</span>

<div class="viewcode-block" id="KMeansClustering.get_number_of_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.get_number_of_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_number_of_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of clusters.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - int : The number of clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span><span class="p">)</span></div>


<div class="viewcode-block" id="KMeansClustering.predict_cluster">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.predict_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">predict_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">points_scaled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the cluster indices to which new data points belong based on the centroids.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_points: The new data points&#39; parameter values as a numpy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array of indices of the closest cluster centroid to each data point.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the dimensionality of the data points does not match that of the centroids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the data points are of the correct dimension</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span>
        <span class="k">if</span> <span class="n">data_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data points dimensionality does not match number of features in centroids.&quot;</span><span class="p">)</span>
        <span class="n">scaled_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">points_scaled</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">):</span>
                <span class="n">scaled_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_funcs</span><span class="p">[</span><span class="n">sc</span><span class="p">][</span><span class="s1">&#39;direct&#39;</span><span class="p">](</span>
                    <span class="n">scaled_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># Calculate the distance from each point to each centroid</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">scaled_points</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>

        <span class="c1"># Find the indices of the nearest centroid for each data point</span>
        <span class="n">nearest_centroid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nearest_centroid_indices</span></div>


<div class="viewcode-block" id="KMeansClustering.from_graph">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.from_graph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_graph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">clustering_parameters</span><span class="p">:</span>  <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>  <span class="n">scale</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Clustering</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an instance of KMeansClustering from a structured data dictionary,</span>
<span class="sd">        applying specified scaling to each parameter if needed.</span>

<span class="sd">        Args:</span>
<span class="sd">            G: HariGraph.</span>
<span class="sd">            clustering_parameters: list of clustering parameters</span>
<span class="sd">            scale: An optional dictionary where keys are parameter names and </span>
<span class="sd">                values are functions (&#39;Linear&#39; or &#39;Tanh&#39;) to be applied to </span>
<span class="sd">                the parameter values before clustering.</span>
<span class="sd">            n_clusters: The number of clusters to form.</span>

<span class="sd">        Returns:</span>
<span class="sd">            KMeansClustering: An instance of KMeansClustering with clusters, centroids, </span>
<span class="sd">                        and labels determined from the data.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If no data points remain after removing NaN values or if</span>
<span class="sd">                        an unknown scaling function is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">gatherer</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">clustering_parameters</span><span class="p">)</span>

        <span class="c1"># Extract nodes and parameter names</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Nodes&#39;</span><span class="p">]</span>
        <span class="n">parameter_names</span> <span class="o">=</span> <span class="n">clustering_parameters</span> <span class="k">if</span> <span class="n">clustering_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;Nodes&#39;</span><span class="p">]</span>

        <span class="c1"># Validate and process scale argument</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;Linear&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length mismatch in scale list&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Linear&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span>

        <span class="c1"># Prepare data array</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameter_names</span> <span class="k">if</span> <span class="n">parameter_names</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Nodes&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Remove NaN values</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[</span><span class="n">valid_indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No data points remain after removing NaN values.&quot;</span><span class="p">)</span>

        <span class="c1"># Apply scaling to the parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">scale_funcs</span><span class="p">[</span><span class="n">sc</span><span class="p">][</span><span class="s1">&#39;direct&#39;</span><span class="p">](</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># Perform clustering</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">node_ids</span><span class="o">=</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameter_names</span><span class="p">,</span>
                         <span class="n">scales</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">cluster_indexes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">clustering</span><span class="o">.</span><span class="n">recluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">clustering</span></div>


<div class="viewcode-block" id="KMeansClustering.recluster">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.recluster">[docs]</a>
    <span class="k">def</span> <span class="nf">recluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">):</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span>
                        <span class="n">n_init</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_indexes</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span></div>


<div class="viewcode-block" id="KMeansClustering.reorder_clusters">
<a class="viewcode-back" href="../../source/hari_plotter.cluster.html#hari_plotter.cluster.KMeansClustering.reorder_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorders clusters and associated information based on a new order.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_order: A list containing the indices of the clusters in their new order.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If new_order does not contain all existing cluster indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;New order must contain all existing cluster indices.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">new_order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">]</span>
        <span class="c1"># Create a mapping from old to new labels</span>
        <span class="n">label_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_order</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">label_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_labels</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span></div>
</div>


    <span class="c1"># def get_values(self, key: Union[str, List[str]], keep_scale: bool = False) -&gt; List[np.ndarray]:</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns the values corresponding to the given parameter(s) for all points in the clusters.</span>

    <span class="c1">#     Args:</span>
    <span class="c1">#         key (Union[str, List[str]]): The parameter name or list of parameter names.</span>
    <span class="c1">#         keep_scale *bool): For the convenience, some values are kept as the values of the scale function of themselves. You might need it as it is kept or the actual values, bu default, you need the actual values.</span>

    <span class="c1">#     Returns:</span>
    <span class="c1">#         List[np.ndarray]: A list of numpy arrays, where each array corresponds to a cluster</span>
    <span class="c1">#                           and contains the values of the specified parameter(s) for each point in that cluster.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if isinstance(key, str):</span>
    <span class="c1">#         # Single parameter requested</span>
    <span class="c1">#         key = [key]</span>

    <span class="c1">#     if not all(k in self.parameters for k in key):</span>
    <span class="c1">#         raise KeyError(</span>
    <span class="c1">#             &quot;One or more requested parameters are not found in the cluster parameters.&quot;)</span>

    <span class="c1">#     param_indices = [self.parameters.index(k) for k in key]</span>

    <span class="c1">#     scaled_data = self.data[:, param_indices]</span>
    <span class="c1">#     if not keep_scale:</span>
    <span class="c1">#         for new_index, original_index in enumerate(param_indices):</span>
    <span class="c1">#             used_scale = self.scales[original_index]</span>
    <span class="c1">#             scaled_data[:, new_index] = self.scale_funcs[used_scale][&#39;inverse&#39;](</span>
    <span class="c1">#                 scaled_data[:, new_index])</span>

    <span class="c1">#     unique = np.unique(self.cluster_indexes)</span>

    <span class="c1">#     return [scaled_data[self.cluster_indexes == u_i, :] for u_i in unique]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Amrita Goswami, Rohit Goswami, Moritz Sallermann, Ivan Tambovtsev.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>